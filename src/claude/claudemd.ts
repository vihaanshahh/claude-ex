import * as fs from 'fs';
import * as path from 'path';
import Database from 'better-sqlite3';
import { openDatabase } from '../db/schema';
import { getRank, getModules, getStats } from '../query/engine';

const MARKER_START = '<!-- codex-engine:start -->';
const MARKER_END = '<!-- codex-engine:end -->';

export function generateClaudeMd(rootDir: string, db?: Database.Database): string {
    const shouldClose = !db;
    if (!db) db = openDatabase(rootDir);

    try {
        const stats = getStats(db);
        const topSymbols = getRank(db, 15);
        const modules = getModules(db);
        const dirname = path.basename(rootDir);

        // Language breakdown
        const langs = db.prepare(`
            SELECT language, COUNT(*) as cnt FROM files WHERE language IS NOT NULL GROUP BY language ORDER BY cnt DESC
        `).all() as { language: string; cnt: number }[];

        const lines: string[] = [];
        lines.push(MARKER_START);
        lines.push(`# Project: ${dirname}`);
        lines.push('');
        lines.push('## Architecture');
        lines.push(`- **Languages**: ${langs.map(l => `${l.language} (${l.cnt} files)`).join(', ')}`);
        lines.push(`- **Size**: ${stats.files} files, ${stats.symbols} symbols, ${stats.edges} relationships`);
        lines.push('');

        if (topSymbols.length > 0) {
            lines.push('## Key Symbols (by structural importance)');
            for (let i = 0; i < topSymbols.length; i++) {
                const sym = topSymbols[i];
                lines.push(`${i + 1}. \`${sym.qualifiedName || sym.name}\` [${sym.kind}] in ${sym.file}`);
            }
            lines.push('');
        }

        if (modules.length > 0) {
            lines.push('## Module Map');
            for (const mod of modules.slice(0, 15)) {
                const imports = mod.importsFrom.length > 0
                    ? ` \u2192 imports from: ${mod.importsFrom.join(', ')}`
                    : ' \u2192 imports from: (none \u2014 leaf dependency)';
                lines.push(`${mod.name}/ (${mod.fileCount} files, ${mod.symbolCount} symbols)${imports}`);
            }
            lines.push('');
        }

        lines.push('*Auto-generated by codex-engine. Run `codex-engine generate-docs` to regenerate.*');
        lines.push(MARKER_END);

        return lines.join('\n');
    } finally {
        if (shouldClose) db.close();
    }
}

export function writeClaudeMd(rootDir: string, db?: Database.Database): void {
    const content = generateClaudeMd(rootDir, db);
    const claudeMdPath = path.join(rootDir, 'CLAUDE.md');

    if (fs.existsSync(claudeMdPath)) {
        const existing = fs.readFileSync(claudeMdPath, 'utf-8');

        if (existing.includes(MARKER_START) && existing.includes(MARKER_END)) {
            // Replace existing section
            const before = existing.slice(0, existing.indexOf(MARKER_START));
            const after = existing.slice(existing.indexOf(MARKER_END) + MARKER_END.length);
            fs.writeFileSync(claudeMdPath, before + content + after);
        } else {
            // Append
            fs.writeFileSync(claudeMdPath, existing.trimEnd() + '\n\n' + content + '\n');
        }
    } else {
        fs.writeFileSync(claudeMdPath, content + '\n');
    }
}
